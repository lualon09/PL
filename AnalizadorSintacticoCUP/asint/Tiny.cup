package asint;

import java_cup.runtime.*;
import alex.AnalizadorLexicoTiny;
import alex.UnidadLexica;
import alex.TokenValue;
import errors.GestionErroresTiny;
// import ast.*;
import java.util.ArrayList;
import ast.Types.*;
import ast.Expressions.*;
import ast.Expressions.Accesses.*;
import ast.Definitions.*;
import ast.Instructions.*;

scan with {: return getScanner().next_token(); :};
parser code {: 
   private GestionErroresTiny errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((UnidadLexica)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErroresTiny();
   AnalizadorLexicoTiny alex = (AnalizadorLexicoTiny)getScanner();
   alex.fijaGestionErrores(errores);
:};


terminal TIPOINT, TIPOBOOL, VOID,
         MAS, MENOS, POR, DIV, MOD, SUMLIST, PRODLIST, 
         MAYOR, MENOR, MAYORIGUAL, MENORIGUAL, DISTINTO, IGUALDAD,
         AND, OR, NOT, PAP, PCIERRE, CAP, CCIERRE, LLAP, LLCIERRE, FLECHA,
         IGUAL, COMA, PUNTOYCOMA, AMPERSAND, PUNTO, DOSPUNTOS, 
         WHILE, FOR, REPEAT, IF, ELSE, STRUCT, SWITCH, VALUEFOR, CASE, BREAK, DEFAULT,
         RETURN, SHOW, READ, TYPEDEF, CONST, LIST, NEW;

terminal TokenValue IDEN, ENT, TRUE, FALSE;

non terminal S,
         VALUEFOREXP, CASEEXPVF, DEFAULTEXPVF, SWITCHEXP, CASEEXP, DEFAULTEXP, SWITCHES;

non terminal T TYPE;
non terminal E E0, E1, E2, E3, E4, E5, E6, E7, E8, ACCESO, NACCESO;
non terminal ENew NEWEXP;
non terminal ERead READFUNC;
non terminal EFunction LLAMADAFUNC;
non terminal ArrayList<E> E9;
non terminal KindE OP0, OP1, OP2, OP3, OP4;
non terminal DefinitionList DECLARATIONS;
non terminal IDeclaration DECLARACION;
non terminal DConst CONSTVAR;
non terminal DStruct STRUCTDEC;
non terminal DFunction  FUNCDEC;
non terminal DTypedef ALIAS;
non terminal IAssignation ASIG;
non terminal ArrayList<IDeclaration> CAMPOS;
non terminal Parameter PARAM;
non terminal ArrayList<Parameter> LISTAPARAMS, PARAMS;
non terminal ArrayList<I> BINST, LISTAINST;
non terminal IShow SHOWFUNC;
non terminal IReturn RETURNFUNC; 
non terminal ArrayList<E> ARGS, LISTAARGS;
non terminal IFunction LLAMADAFUNCINST;
non terminal IIfElse CONDICIONALES;
non terminal IBlock BUCLES;
non terminal IBlock BLOQUE;
non terminal I INST;


//------------Declaraciones de constantes, funciones, alias, structs y la función main--------------  ?????VARIABLES GLOBALES????'

//----Programa Principal----
S ::=  DECLARATIONS;

//----Declaracion de variables y asignacion--

DECLARATIONS ::= DECLARACION:d DECLARATIONS:list
                 {:list.addVar(d); RESULT = list;:}
                 | CONSTVAR:c DECLARATIONS:list
                 {:list.addConst(c); RESULT = list;:}
                 | STRUCTDEC:s DECLARATIONS:list
                 {:list.addStruct(s); RESULT = list;:}
                 | ALIAS:t DECLARATIONS:list
                 {:list.addTypedef(t); RESULT = list;:} 
                 | FUNCDEC:f DECLARATIONS:list
                 {:list.addFunc(f); RESULT = list;:} 
                 | 
                 {:RESULT = new DefinitionList();:};

DECLARACION ::= TYPE:t IDEN:name PUNTOYCOMA
                {:IDeclaration var = new IDeclaration(t, name.lexema); RESULT = var;:}
               | TYPE:t IDEN:name IGUAL E0:e PUNTOYCOMA
               {:IDeclaration var = new IDeclaration(t, name.lexema, e); RESULT = var;:};

ASIG ::= ACCESO:a IGUAL E0:e PUNTOYCOMA 
         {:RESULT = new IAssignation((A) a, e);:};

//----Constantes----
CONSTVAR ::= CONST TYPE:t IDEN:name IGUAL E0:e PUNTOYCOMA
            {:RESULT = new DConst(t, name.lexema, e);:};

//----Declaracion de Structs----
STRUCTDEC ::= STRUCT IDEN:name LLAP CAMPOS:c LLCIERRE PUNTOYCOMA 
            {:RESULT = new DStruct(name.lexema, c);:};
CAMPOS   ::= DECLARACION:d CAMPOS:list
            {:list.add(d); RESULT = list;:}
            | DECLARACION:d
            {:ArrayList<IDeclaration> list = new ArrayList<IDeclaration>(); list.add(d); RESULT = list;:};

//----Alias----
ALIAS ::= TYPEDEF IDEN:name IGUAL TYPE:t PUNTOYCOMA
         {:RESULT = new DTypedef(name.lexema, t);:};

//----Declaracion de funciones----
FUNCDEC ::= IDEN:name PAP PARAMS:p PCIERRE FLECHA TYPE:tReturn BINST:i 
            {:RESULT = new DFunction(name.lexema,i,p,tReturn);:};

PARAMS ::= LISTAPARAMS:list
           {:RESULT = list;:}
           | 
           {:RESULT = new ArrayList<Parameter>();:};
LISTAPARAMS ::= PARAM:p COMA LISTAPARAMS:l
                {:l.add(p); RESULT = l;:}
                | PARAM:p
                {:ArrayList<Parameter> l = new ArrayList<Parameter>(); l.add(p); RESULT = l;:};
PARAM ::= IDEN:name DOSPUNTOS TYPE:t 
          {:RESULT = new Parameter(name.lexema, t, false);:}
          | IDEN:name DOSPUNTOS AMPERSAND TYPE:t 
          {:RESULT = new Parameter(name.lexema, t, true);:};

//-------------------------------Instrucciones---------------------------------------------

//----Listas de instrucciones----
LISTAINST ::= INST:i LISTAINST:list
              {:list.add(i); RESULT = list;:}
              | BLOQUE:b LISTAINST:list
              {:list.add(b); RESULT = list;:} 
              | 
              {:RESULT = new ArrayList<I>();:};

INST ::= DECLARACION:d
         {:RESULT = d;:}
         | ASIG:a 
         {:RESULT = a;:} 
         | SHOWFUNC:s
         {:RESULT = s;:}
         | RETURNFUNC:r
         {:RESULT = r; :}
         | LLAMADAFUNCINST:l
         {:RESULT = l;:} ;

//----Show----
SHOWFUNC ::= SHOW PAP E0:e PCIERRE PUNTOYCOMA 
            {:RESULT = new IShow(e);:};

//----Read----
READFUNC ::= READ PAP PCIERRE;

//----Return----
RETURNFUNC ::= RETURN E0:e PUNTOYCOMA 
               {:RESULT = new IReturn(e);:}
               | RETURN PUNTOYCOMA 
               {:RESULT = new IReturn();:};

LLAMADAFUNCINST ::= LLAMADAFUNC:f PUNTOYCOMA
                    {:RESULT = new IFunction(f);:};

//----LLamada a funcion----
LLAMADAFUNC ::= IDEN:name PAP ARGS:a PCIERRE
                {:RESULT = new EFunction(name.lexema, a);:};  

ARGS ::= LISTAARGS:l
         {:RESULT = l;:}
         | 
         {:RESULT = new ArrayList<E>();:};
LISTAARGS ::= E0:e COMA LISTAARGS:l
              {:l.add(e); RESULT = l;:}
              | E0:e 
              {:ArrayList<E> l = new ArrayList<E>(); l.add(e); RESULT = l;:};

//--------------------Bloques, Condicionales, Bucles y Switches--------------------------

//----Bloques----
BLOQUE ::= BINST:list
      {:RESULT = new IBlock(list);:}
       | CONDICIONALES:c
       {:RESULT = c;:}
       | BUCLES:b
       {:RESULT = b;:}
       | SWITCHES;

BINST ::= LLAP LISTAINST:list LLCIERRE
          {:RESULT = list;:};

//----Condicionales----
CONDICIONALES ::= IF PAP E0:e PCIERRE BINST:list
                  {:RESULT = new IIfElse(e, list);:}
                  | IF PAP E0:e PCIERRE BINST:listIf ELSE BINST:listElse
                   {:RESULT = new IIfElse(e, listIf, listElse);:};

//----Bucles----
BUCLES ::= WHILE PAP E0:e PCIERRE BINST:list
           {:RESULT = new IWhile(e, list);:}
           | FOR PAP DECLARACION:d E0:exp PUNTOYCOMA ACCESO:a IGUAL E0:exp2 PCIERRE BINST:list 
           {:RESULT = new IFor(d, exp, new IAssignation((A) a, exp2), list);:}
           | REPEAT PAP E0:e PCIERRE BINST:list
           {:RESULT = new IRepeat(e, list);:};

//----Switches----
SWITCHES ::= SWITCHEXP | VALUEFOREXP ;

SWITCHEXP ::= SWITCH PAP IDEN PCIERRE LLAP CASEEXP DEFAULTEXP LLCIERRE | SWITCH PAP IDEN PCIERRE LLAP CASEEXP LLCIERRE; 
CASEEXP	::= CASE E0 DOSPUNTOS LISTAINST BREAK PUNTOYCOMA CASEEXP | CASE E0 DOSPUNTOS LISTAINST PUNTOYCOMA CASEEXP | ;

DEFAULTEXP ::= DEFAULT DOSPUNTOS LISTAINST;

VALUEFOREXP ::= VALUEFOR PAP IDEN PCIERRE LLAP CASEEXPVF DEFAULTEXPVF LLCIERRE ;       //NO ESTOY SEGURO DE QUE ESTO ESTÉ BIEN. Tendríamos que poner un acceso a la variable yo creo pero no se como
CASEEXPVF ::= CASE E0 IGUAL E0 PUNTOYCOMA BREAK PUNTOYCOMA CASEEXPVF | ;
DEFAULTEXPVF ::= DEFAULT IGUAL E0 PUNTOYCOMA ;



//-------------------------------------Expresiones----------------------------------------

//----Expresiones----
E0 ::= E0:op1 OR E1:op2
      {: RESULT = new EBin(op1, op2, KindE.OR, new TBasics(KindT.BOOL));:}
      | E1:e 
      {:RESULT = e;:};

E1 ::= E1:op1 AND E2:op2
      {: RESULT = new EBin(op1, op2, KindE.AND, new TBasics(KindT.BOOL)); :}
      | E2:e 
      {:RESULT = e;:};

E2 ::= E2:op1 OP0:operator E3:op2 
      {: RESULT = new EBin(op1, op2, operator, new TBasics(KindT.BOOL)); :}
      | E3:e 
      {:RESULT = e;:};

E3 ::= E3:op1 OP1:operator E4:op2
      {: RESULT = new EBin(op1, op2, operator, new TBasics(KindT.BOOL)); :}
      | E4:e
      {:RESULT = e;:}
      | NEWEXP:nexp 
      {:RESULT = nexp;:};

E4 ::= E4:op1 OP2:operator E5:op2 
      {: RESULT = new EBin(op1, op2, operator, new TBasics(KindT.INT));:}
      | E5:e
      {:RESULT = e;:} ;

E5 ::= E5:op1 OP3:operator E6:op2
      {: RESULT = new EBin(op1, op2, operator, new TBasics(KindT.INT));:}
      | E6:e 
      {:RESULT = e;:};

E6 ::= NOT E6:op1 
      {:RESULT = new EUnary(op1, KindE.NOT, new TBasics(KindT.BOOL));:}
      | E7:e 
      {:RESULT = e;:};

E7 ::= OP4:operator E7:op1
      {:RESULT = new EUnary(op1, operator, new TArray(new TBasics(KindT.INT)));:} //estos operadores solo se pueden con arrays de enteros
      | E8:e 
      {:RESULT = e;:};

E8 ::= ENT:value
      {:RESULT = new EConst(value.lexema, new TBasics(KindT.INT));:}
      | TRUE:value
      {:RESULT = new EConst(value.lexema, new TBasics(KindT.BOOL));:} 
      | FALSE:value
      {:RESULT = new EConst(value.lexema, new TBasics(KindT.BOOL));:} 
      | ACCESO:access 
      {:RESULT = access;:} 
      | LLAMADAFUNC:callFunc
      {:RESULT = callFunc;:} 
      | READFUNC:read
      {:RESULT = read;:} 
      | LLAP E0:elem E9:elems LLCIERRE
      {:elems.add(elem); RESULT = new EArray(elems);:};

E9 ::= COMA E0:e E9:list 
      {:list.add(e); RESULT = list;:}
      | 
      {:ArrayList<E> l = new ArrayList<E>(); RESULT = l;:};

//----Operadores----
OP0 ::= DISTINTO:d
      {:d = KindE.DISTINCT;:}
      | IGUALDAD:e
      {:e = KindE.EQUAL;:};

OP1 ::= MENOR:m
       {:m = KindE.LESS;:}
       | MAYOR:ma
       {:ma = KindE.GREATER;:}
       | MENORIGUAL:me
       {:me = KindE.LEQ;:} 
       | MAYORIGUAL:may
       {:may = KindE.GREQ;:};

OP2 ::= MAS:m
      {:m = KindE.SUM;:}
      | MENOS:me
      {:me = KindE.SUB;:};

OP3 ::= POR:p
       {:p = KindE.MUL;:}
       | DIV:d
       {:d = KindE.DIV;:} 
       | MOD:m
       {:m = KindE.MOD;:};

OP4 ::= SUMLIST:s
      {:s = KindE.SUML;:}
      | PRODLIST:p 
      {:p= KindE.PRODL;:} ;

//----New--------
NEWEXP ::= NEW TYPE:t 
         {:RESULT = new ENew(t);:};

//--------------------------------------Tipos--------------------------------------------
TYPE ::= TIPOINT
         {: RESULT = new TBasics(KindT.INT);:}
         | TIPOBOOL 
         {: RESULT = new TBasics(KindT.BOOL);:}
         | VOID 
         {: RESULT = new TBasics(KindT.VOID);:}
         | IDEN:id
         {: RESULT = new TStruct(id.lexema);:}
         | LIST MENOR TYPE:t MAYOR CAP ENT:size CCIERRE //hemos puesto ENT en vez de E0 para el token value
         {: EConst sizeConst = new EConst(size.lexema, new TBasics(KindT.INT)); RESULT = new TArray(t, sizeConst);:}
         | TYPE:t POR 
         {: RESULT = new TPointer(t);:};

//-------------------------------------Accesos------------------------------------------
ACCESO ::= ACCESO:a CAP E0:e CCIERRE 
          {:RESULT = new AArray((A) a, e);:}
          | ACCESO:a PUNTO IDEN:id
          {:RESULT = new AStruct((A) a, id.lexema);:} 
          | PAP E0:e PCIERRE
          {:RESULT = e;:} 
          | NACCESO:na
          {:RESULT = na;:};

NACCESO ::= IDEN:id
            {: RESULT = new AVariable(id.lexema);:}
            | POR NACCESO:na
            {: RESULT = new APointer((A) na);:} 
            | AMPERSAND NACCESO:na 
            {:RESULT = new AAdPointer((A) na);:};