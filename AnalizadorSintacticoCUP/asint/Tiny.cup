package asint;

import java_cup.runtime.*;
import alex.AnalizadorLexicoTiny;
import alex.UnidadLexica;
import alex.TokenValue;
import errors.GestionErroresTiny;
// import ast.*;
import java.util.ArrayList;
import ast.Types.*;
import ast.Expressions.*;
import ast.Expressions.Accesses.*;

scan with {: return getScanner().next_token(); :};
parser code {: 
   private GestionErroresTiny errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((UnidadLexica)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErroresTiny();
   AnalizadorLexicoTiny alex = (AnalizadorLexicoTiny)getScanner();
   alex.fijaGestionErrores(errores);
:};


terminal TIPOINT, TIPOBOOL, VOID,
         MAS, MENOS, POR, DIV, MOD, SUMLIST, PRODLIST, 
         MAYOR, MENOR, MAYORIGUAL, MENORIGUAL, DISTINTO, IGUALDAD,
         AND, OR, NOT, PAP, PCIERRE, CAP, CCIERRE, LLAP, LLCIERRE, FLECHA,
         IGUAL, COMA, PUNTOYCOMA, AMPERSAND, PUNTO, DOSPUNTOS, 
         WHILE, FOR, REPEAT, IF, ELSE, STRUCT, SWITCH, VALUEFOR, CASE, BREAK, DEFAULT,
         RETURN, SHOW, READ, TYPEDEF, CONST, LIST, NEW;

terminal TokenValue IDEN, ENT, TRUE, FALSE;

non terminal S, CONSTVAR,  
         STRUCTDEC,
         INST, BLOQUE , WHILEEXP, FOREXP, REPEATEXP, VALUEFOREXP, 
         SWITCHEXP, CASEEXP, CASEEXPVF, ASIG, FUNCDEC, PARAMS, ALIAS, 
         ARGS, CAMPOS, DECLARACION, LISTAINST, RETURNFUNC, SHOWFUNC, LLAMADAFUNCAUX,
         CONDICIONALES, BUCLES, SWITCHES, BINST, DEFAULTEXP, DEFAULTEXPVF, PARAM, LISTAPARAMS, LISTAARGS;

non terminal T TYPE;
non terminal E E0, E1, E2, E3, E4, E5, E6, E7, E8, NEWEXP, READFUNC, LLAMADAFUNC, ACCESO, NACCESO;
non terminal ArrayList<E> E9;
non terminal KindE OP0, OP1, OP2, OP3, OP4;
non terminal DefinitionList LISTADEC;

//------------Declaraciones de constantes, funciones, alias, structs y la función main--------------  ?????VARIABLES GLOBALES????'

//----Programa Principal----
S ::=  DECLARACION S 
      // me está rayando
      | CONSTVAR S
      | STRUCTDEC S 
      | ALIAS S 
      | FUNCDEC S 
      | ;

//----Declaracion de variables y asignacion---


DECLARACION ::= TYPE:t IDEN:name LISTADEC:list PUNTOYCOMA
                {:IDeclaration var = new IDeclaration(t, name.lexema); list.addVar(var); RESULT = list;:}
               | TYPE IDEN:name IGUAL E0:e LISTADEC:list PUNTOYCOMA
               {:IDeclaration var = new IDeclaration(t, name.lexema, e); list.addVar(var); RESULT = list;:};

LISTADEC ::= COMA IDEN:name LISTADEC:list
            {::}
            | COMA IDEN:name IGUAL E0:e LISTADEC:list 
            | 
            {:RESULT = new DefinitionList();:};

ASIG ::= ACCESO IGUAL E0 PUNTOYCOMA ;

//----Constantes----
CONSTVAR ::= CONST DECLARACION;

//----Declaracion de Structs----
STRUCTDEC ::= STRUCT IDEN LLAP CAMPOS LLCIERRE PUNTOYCOMA ;
CAMPOS   ::= DECLARACION CAMPOS | DECLARACION;

//----Alias----
ALIAS ::= TYPEDEF IDEN IGUAL TYPE PUNTOYCOMA;

//----Declaracion de funciones----
FUNCDEC ::= IDEN PAP PARAMS PCIERRE FLECHA TYPE BINST ;
PARAMS ::= LISTAPARAMS | ;
LISTAPARAMS ::= PARAM COMA LISTAPARAMS | PARAM ;
PARAM ::= IDEN DOSPUNTOS TYPE | IDEN DOSPUNTOS AMPERSAND TYPE ;


//-------------------------------Instrucciones---------------------------------------------

//----Listas de instrucciones----
LISTAINST ::= INST LISTAINST | BLOQUE LISTAINST | ;
INST ::= DECLARACION | ASIG | SHOWFUNC | RETURNFUNC | LLAMADAFUNCAUX ;

//----Show----
SHOWFUNC ::= SHOW PAP E0 PCIERRE PUNTOYCOMA ;

//----Read----
READFUNC ::= READ PAP PCIERRE ;

//----Return----
RETURNFUNC ::= RETURN E0 PUNTOYCOMA | RETURN PUNTOYCOMA ;         //FUNCIONES VOID?????????

//----LLamada a funcion----
LLAMADAFUNCAUX ::= LLAMADAFUNC PUNTOYCOMA ;
LLAMADAFUNC ::= IDEN PAP ARGS PCIERRE ;  
ARGS ::= LISTAARGS | ;
LISTAARGS ::= E0 COMA ARGS | E0 ;



//--------------------Bloques, Condicionales, Bucles y Switches--------------------------

//----Bloques----
BLOQUE ::= BINST | CONDICIONALES | BUCLES | SWITCHES;
BINST ::= LLAP LISTAINST LLCIERRE;

//----Condicionales----
CONDICIONALES ::= IF PAP E0 PCIERRE BINST | IF PAP E0 PCIERRE BINST ELSE BINST ;

//----Bucles----
BUCLES ::= WHILEEXP | FOREXP | REPEATEXP ;
WHILEEXP ::= WHILE PAP E0 PCIERRE BINST ;
FOREXP ::= FOR PAP DECLARACION E0 PUNTOYCOMA ACCESO IGUAL E0 PCIERRE BINST ; 
REPEATEXP ::= REPEAT PAP E0 PCIERRE BINST ;

//----Switches----
SWITCHES ::= SWITCHEXP | VALUEFOREXP ;

SWITCHEXP ::= SWITCH PAP IDEN PCIERRE LLAP CASEEXP DEFAULTEXP LLCIERRE ;
CASEEXP	::= CASE E0 DOSPUNTOS LISTAINST BREAK PUNTOYCOMA CASEEXP |;
DEFAULTEXP ::= DEFAULT DOSPUNTOS LISTAINST ;

VALUEFOREXP ::= VALUEFOR PAP IDEN PCIERRE LLAP CASEEXPVF DEFAULTEXPVF LLCIERRE ;       //NO ESTOY SEGURO DE QUE ESTO ESTÉ BIEN. Tendríamos que poner un acceso a la variable yo creo pero no se como
CASEEXPVF ::= CASE E0 IGUAL E0 PUNTOYCOMA BREAK PUNTOYCOMA CASEEXPVF | ;
DEFAULTEXPVF ::= DEFAULT IGUAL E0 PUNTOYCOMA ;



//-------------------------------------Expresiones----------------------------------------

//----Expresiones----
E0 ::= E0:op1 OR E1:op2
      {: RESULT = new EBin(op1, op2, KindE.OR, new TBasics(KindT.BOOL));:}
      | E1:e 
      {:RESULT = e;:};

E1 ::= E1:op1 AND E2:op2
      {: RESULT = new EBin(op1, op2, KindE.AND, new TBasics(KindT.BOOL)); :}
      | E2:e 
      {:RESULT = e;:};

E2 ::= E2:op1 OP0:operator E3:op2 
      {: RESULT = new EBin(op1, op2, operator, new TBasics(KindT.BOOL)); :}
      | E3:e 
      {:RESULT = e;:};

E3 ::= E3:op1 OP1:operator E4:op2
      {: RESULT = new EBin(op1, op2, operator, new TBasics(KindT.BOOL)); :}
      | E4:e
      {:RESULT = e;:}
      | NEWEXP:nexp 
      {:RESULT = nexp;:};

E4 ::= E4:op1 OP2:operator E5:op2 
      {: RESULT = new EBin(op1, op2, operator, new TBasics(KindT.INT));:}
      | E5:e
      {:RESULT = e;:} ;

E5 ::= E5:op1 OP3:operator E6:op2
      {: RESULT = new EBin(op1, op2, operator, new TBasics(KindT.INT));:}
      | E6:e 
      {:RESULT = e;:};

E6 ::= NOT E6:op1 
      {:RESULT = new EUnary(op1, KindE.NOT, new TBasics(KindT.BOOL));:}
      | E7:e 
      {:RESULT = e;:};

E7 ::= OP4:operator E7:op1
      {:RESULT = new EUnary(op1, operator, new TArray(new TBasics(KindT.INT)));:} //estos operadores solo se pueden con arrays de enteros
      | E8:e 
      {:RESULT = e;:};

E8 ::= ENT:value
      {:RESULT = new EConst(value.lexema, new TBasics(KindT.INT));:}
      | TRUE:value
      {:RESULT = new EConst(value.lexema, new TBasics(KindT.BOOL));:} 
      | FALSE:value
      {:RESULT = new EConst(value.lexema, new TBasics(KindT.BOOL));:} 
      | ACCESO:access 
      {:RESULT = access;:} 
      | LLAMADAFUNC:callFunc
      {:RESULT = callFunc;:} 
      | READFUNC:read
      {:RESULT = read;:} 
      | LLAP E0:elem E9:elems LLCIERRE
      {:elems.add(elem); RESULT = new EArray(elems);:};

E9 ::= COMA E0:e E9:list 
      {:list.add(e); RESULT = list;:}
      | 
      {:ArrayList<E> l = new ArrayList<E>(); RESULT = l;:};

//----Operadores----
OP0 ::= DISTINTO:d
      {:d = KindE.DISTINCT;:}
      | IGUALDAD:e
      {:e = KindE.EQUAL;:};

OP1 ::= MENOR:m
       {:m = KindE.LESS;:}
       | MAYOR:ma
       {:ma = KindE.GREATER;:}
       | MENORIGUAL:me
       {:me = KindE.LEQ;:} 
       | MAYORIGUAL:may
       {:may = KindE.GREQ;:};

OP2 ::= MAS:m
      {:m = KindE.SUM;:}
      | MENOS:me
      {:me = KindE.SUB;:};

OP3 ::= POR:p
       {:p = KindE.MUL;:}
       | DIV:d
       {:d = KindE.DIV;:} 
       | MOD:m
       {:m = KindE.MOD;:};

OP4 ::= SUMLIST:s
      {:s = KindE.SUML;:}
      | PRODLIST:p 
      {:p= KindE.PRODL;:} ;

//----New--------
NEWEXP ::= NEW TYPE:t 
         {:RESULT = new ENew(t);:};

//--------------------------------------Tipos--------------------------------------------
TYPE ::= TIPOINT
         {: RESULT = new TBasics(KindT.INT);:}
         | TIPOBOOL 
         {: RESULT = new TBasics(KindT.BOOL);:}
         | VOID 
         {: RESULT = new TBasics(KindT.VOID);:}
         | IDEN:id
         {: RESULT = new TStruct(id.lexema);:}
         | LIST MENOR TYPE:t MAYOR CAP ENT:size CCIERRE //hemos puesto ENT en vez de E0 para el token value
         {: EConst sizeConst = new EConst(size.lexema, new TBasics(KindT.INT)); RESULT = new TArray(t, sizeConst);:}
         | TYPE:t POR 
         {: RESULT = new TPointer(t);:};

//-------------------------------------Accesos------------------------------------------
ACCESO ::= ACCESO:a CAP E0:e CCIERRE 
          {:RESULT = new AArray((A) a, e);:}
          | ACCESO:a PUNTO IDEN:id
          {:RESULT = new AStruct((A) a, id.lexema);:} 
          | PAP E0:e PCIERRE
          {:RESULT = e;:} 
          | NACCESO:na
          {:RESULT = na;:};

NACCESO ::= IDEN:id
            {: RESULT = new AVariable(id.lexema);:}
            | POR NACCESO:na
            {: RESULT = new APointer((A) na);:} 
            | AMPERSAND NACCESO:na 
            {:RESULT = new AAdPointer((A) na);:};

