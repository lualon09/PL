package asint;

import java_cup.runtime.*;
import alex.AnalizadorLexicoTiny;
import alex.UnidadLexica;
import errors.GestionErroresTiny;

scan with {: return getScanner().next_token(); :};
parser code {: 
   private GestionErroresTiny errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((UnidadLexica)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErroresTiny();
   AnalizadorLexicoTiny alex = (AnalizadorLexicoTiny)getScanner();
   alex.fijaGestionErrores(errores);
:};


terminal  IDEN, TIPOINT, TIPOBOOL, TIPOSTRUCT, VOID,
         ENT, TRUE, FALSE, MAS, MENOS, POR, DIV, MOD, SUMLIST, PRODLIST, 
         MAYOR, MENOR, MAYORIGUAL, MENORIGUAL, DISTINTO, IGUALDAD,
         AND, OR, NOT, PAP, PCIERRE, CAP, CCIERRE, LLAP, LLCIERRE, FLECHA,
         IGUAL, COMA, PUNTOYCOMA, AMPERSAND, PUNTO, DOSPUNTOS, 
         WHILE, FOR, REPEAT, IF, ELSE, STRUCT, SWITCH, VALUEFOR, CASE, BREAK, DEFAULT,
         RETURN, SHOW, READ, MAIN, TYPEDEF, CONST, LIST, NEW;

non terminal S, CONSTVAR, TYPE, E0, E1, E2, E3, E4, E5, E6, E7, E8,
         OP0, OP1, OP2, OP3, OP4, ACCESO, NACCESO, STRUCTDEC, MAINFUNC,
         INST, BLOQUE , WHILEEXP, FOREXP, REPEATEXP, VALUEFOREXP, 
         SWITCHEXP, CASEEXP, CASEEXPVF, ASIG, FUNCDEC, PARAMS, ALIAS, LLAMADAFUNC, 
         ARGS, CAMPOS, DECLARACION, LISTAINST, RETURNFUNC, SHOWFUNC, READFUNC, LLAMADAFUNCAUX
         CONDICIONALES, BUCLES, SWITCHES, BINST, DEFAULTEXP, DEFAULTEXPVF, PARAM, LISTAPARAM, LISTAARGS, NEWEXP;


//------------Declaraciones de constantes, funciones, alias, structs y la función main--------------  ?????VARIABLES GLOBALES????'

//----Programa Principal----
S ::=  DECLARACION S | CONSTVAR S | STRUCTDEC S | ALIAS S | FUNCDEC S | MAINFUNC ;

//----Declaracion de variables y asignacion----
DECLARACION ::= TYPE IDEN IGUAL E0 PUNTOYCOMA | TYPE IDEN PUNTOYCOMA;
ASIG ::= ACCESO IGUAL E0 PUNTOYCOMA ;

//----Constantes----
CONSTVAR ::= CONST DECLARACION;

//----Declaracion de Structs----
STRUCTDEC ::= STRUCT TIPOSTRUCT LLAP CAMPOS LLCIERRE PUNTOYCOMA ;
CAMPOS   ::= DECLARACION CAMPOS | DECLARACION;

//----Alias----
ALIAS ::= TYPEDEF IDEN IGUAL TYPE PUNTOYCOMA;

//----Declaracion de funciones----
FUNCDEC ::= IDEN PAP PARAMS PCIERRE FLECHA TYPE BLOQUEINST ;
PARAMS ::= LISTAPARAMS | ;
LISTAPARAMS ::= PARAM COMA LISTAPARAMS | PARAM ;
PARAM ::= IDEN DOSPUNTOS TYPE | IDEN DOSPUNTOS AMPERSAND TYPE ;

//----Funcion main----
MAINFUNC ::= MAIN PAP PCIERRE FLECHA TYPE BINST ;            //RETURN 0???



//-------------------------------Instrucciones---------------------------------------------

//----Listas de instrucciones----
LISTAINST ::= INST LISTAINST | BLOQUE LISTAINST | ;
INST ::= DECLARACION | ASIG | SHOWFUNC | RETURNFUNC | LLAMADAFUNCAUX ;

//----Show----
SHOWFUNC ::= SHOW PAP E0 PCIERRE PUNTOYCOMA ;

//----Read----
READFUNC ::= READ PAP PCIERRE ;

//----Return----
RETURNFUNC ::= RETURN E0 PUNTOYCOMA | RETURN PUNTOYCOMA ;         //FUNCIONES VOID?????????

//----LLamada a funcion----
LLAMADAFUNCAUX ::= LLAMADAFUNC PUNTOYCOMA ;
LLAMADAFUNC ::= IDEN PAP ARGS PCIERRE ;  
ARGS ::= LISTAARGS | ;
LISTAARGS ::= E0 COMA ARGS | E0 ;



//--------------------Bloques, Condicionales, Bucles y Switches--------------------------

//----Bloques----
BLOQUE ::= BINST | CONDICIONALES | BUCLES | SWITCHES;
BINST ::= LLAP LISTAINST LLCIERRE

//----Condicionales----
CONDICIONALES ::= IF PAP E0 PCIERRE BINST | IF PAP E0 PCIERRE BINST ELSE BINST ;

//----Bucles----
BUCLES := WHILEEXP | FOREXP | REPEATEXP ;
WHILEEXP ::= WHILE PAP E0 PCIERRE BINST ;
FOREXP ::= FOR PAP DECLARACION E0 PUNTOYCOMA ACCESO IGUAL E0 PCIERRE BLOQUEINST ; 
REPEATEXP ::= REPEAT PAP E0 PCIERRE BLOQUEINST ;

//----Switches----
SWITCHES ::= SWITCHEXP | VALUEFOREXP ;

SWITCHEXP ::= SWITCH PAP IDEN PCIERRE LLAP CASEEXP DEFAULTEXP LLCIERRE ;
CASEEXP	::= CASE E0 DOSPUNTOS LISTAINST  BREAK PUNTOYCOMA CASEEXP ;
DEFAULTEXP ::= DEFAULT DOSPUNTOS LISTAINST ;

VALUEFOREXP ::= VALUEFOR PAP IDEN PCIERRE LLAP CASEEXPVF DEFAULTEXPVF LLCIERRE ;       //NO ESTOY SEGURO DE QUE ESTO ESTÉ BIEN. Tendríamos que poner un acceso a la variable yo creo pero no se como
CASEEXPVF ::= CASE E0 IGUAL E0 PUNTOYCOMA BREAK PUNTOYCOMA CASEEXPVF ;
DEFAULTEXPVF ::= DEFAULT IGUAL E0 PUNTOYCOMA ;



//-------------------------------------Expresiones----------------------------------------

//----Expresiones----
E0 ::= E0 OR E1 | E1 ;
E1 ::= E1 AND E2 | E2 ;
E2 ::= E2 OP0 E3 | E3 ;
E3 ::= E3 OP1 E4 | E4 | NEWEXP ;
E4 ::= E4 OP2 E5 | E5 ;
E5 ::= E5 OP3 E6 | E6 ;
E6 ::= NOT E6 | E7;
E7 ::= OP4 E7 | E8;
E8 ::= ENT | TRUE | FALSE | ACCESO | LLAMADAFUNC | READFUNC | PAP E0 PCIERRE ;

//----Operadores----
OP0 ::= DISTINTO | IGUALDAD ;
OP1 ::= MENOR | MAYOR | MENORIGUAL | MAYORIGUAL ;
OP2 ::= MAS  | MENOS ;
OP3 ::= POR | DIV | MOD ;
OP4 ::= SUMLIST | PRODLIST ;

//----New--------
NEWEXP ::= NEW TYPE ;



//--------------------------------------Tipos--------------------------------------------
TYPE ::= TIPOINT | TIPOBOOL | VOID | TIPOSTRUCT | LIST MENOR TYPE MAYOR CAP ENT CCIERRE | TYPE POR ;



//-------------------------------------Accesos------------------------------------------
ACCESO ::= ACCESO CAP E0 CCIERRE | ACCESO PUNTO IDEN | NACCESO ;        //PODER LLAMAR A FUNCIONES DESDE UNA VARIABLE, ROLLO var1.getInt() o con structs???'
NACCESO ::= IDEN | POR NACCESO | AMPERSAND NACCESO ;                    //FALTARIA PUNTEROS DE PUNTEROS??????? LO PERMITIMOS????



